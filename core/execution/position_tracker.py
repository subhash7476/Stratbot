"""
Position Tracker
----------------
Single source of truth for execution-owned positions.
Maintains in-memory state of what the engine currently holds.
"""

from typing import Dict
from datetime import datetime
from core.execution.position_models import Position, PositionSide
from core.execution.order_models import OrderSide
from core.execution.order_lifecycle import FillEvent
from core.instruments.instrument_parser import InstrumentParser
from core.instruments.instrument_base import Instrument


class PositionTracker:
    """
    Tracks positions for all symbols.
    Updates are driven by filled orders (simulated or real).
    """

    def __init__(self, position_repo=None):
        self._positions: Dict[str, Position] = {}
        self.position_repo = position_repo

    def get_position(self, symbol: str) -> Position:
        """Get current position for a symbol. Returns FLAT position if none exists."""
        if symbol in self._positions:
            return self._positions[symbol]
        instrument = InstrumentParser.parse(symbol)
        return Position(instrument=instrument)

    def has_open_position(self, symbol: str) -> bool:
        """Check if there is an active LONG or SHORT position."""
        return self.get_position(symbol).side != PositionSide.FLAT

    def net_quantity(self, symbol: str) -> float:
        """Get signed quantity (Positive for LONG, Negative for SHORT)."""
        pos = self.get_position(symbol)
        if pos.side == PositionSide.FLAT:
            return 0.0
        return pos.quantity if pos.side == PositionSide.LONG else -pos.quantity

    def get_position_quantity(self, symbol: str) -> float:
        """Compatibility method for TradingRunner. Alias for net_quantity()."""
        return self.net_quantity(symbol)

    def update_from_fill(self, fill: FillEvent, persist: bool = True) -> float:
        """
        Update position state based on an incremental fill event.
        Handles netting, flipping, and average price calculations.
        Returns the Realized PnL generated by this fill.
        """
        symbol = fill.symbol
        side = OrderSide(fill.side)
        fill_qty = fill.quantity
        fill_price = fill.price

        pos = self.get_position(symbol)

        # 1. Determine current signed quantity
        current_signed_qty = self.net_quantity(symbol)

        # 2. Determine fill signed quantity
        fill_signed_qty = fill_qty if side == OrderSide.BUY else -fill_qty

        # 3. Calculate new signed quantity
        new_signed_qty = current_signed_qty + fill_signed_qty

        # 4. Determine new side and absolute quantity
        if new_signed_qty == 0:
            new_side = PositionSide.FLAT
            new_abs_qty = 0.0
        elif new_signed_qty > 0:
            new_side = PositionSide.LONG
            new_abs_qty = new_signed_qty
        else:
            new_side = PositionSide.SHORT
            new_abs_qty = abs(new_signed_qty)

        # Calculate Realized PnL
        # Realized PnL occurs when reducing exposure (closing)
        realized_pnl = 0.0

        # Determine if we are reducing or flipping
        # If signs are different (flipping) or abs(new) < abs(old) (reducing)
        is_reducing_or_flipping = (current_signed_qty > 0 and fill_signed_qty < 0) or \
                                  (current_signed_qty < 0 and fill_signed_qty > 0)

        if is_reducing_or_flipping and current_signed_qty != 0:
            # Quantity closed is the overlap between current and fill
            # If flipping, we closed the entire current qty. If reducing, we closed the fill qty.
            qty_closed = min(abs(current_signed_qty), abs(fill_signed_qty))
            price_diff = fill_price - pos.avg_price
            realized_pnl = price_diff * qty_closed * pos.instrument.multiplier * \
                (1 if current_signed_qty > 0 else -1)

        # 5. Calculate new average price
        new_avg_price = pos.avg_price

        # Logic:
        # - Opening/Increasing: Weighted Average
        # - Reducing: Price stays same
        # - Flipping: Price becomes fill price
        # - Closing (Flat): Price becomes 0

        is_opening = (current_signed_qty == 0 and new_signed_qty != 0)
        is_flipping = (current_signed_qty > 0 and new_signed_qty < 0) or \
                      (current_signed_qty < 0 and new_signed_qty > 0)
        is_increasing = (current_signed_qty > 0 and fill_signed_qty > 0) or \
                        (current_signed_qty < 0 and fill_signed_qty < 0)

        if new_side == PositionSide.FLAT:
            new_avg_price = 0.0
        elif is_opening or is_flipping:
            new_avg_price = fill_price
        elif is_increasing:
            total_value = (abs(current_signed_qty) * pos.avg_price) + \
                (fill_qty * fill_price)
            new_avg_price = total_value / new_abs_qty
        # Else reducing: average price remains unchanged

        # 6. Update state
        new_position = Position(
            instrument=pos.instrument,
            side=new_side,
            quantity=new_abs_qty,
            avg_price=new_avg_price,
            last_updated=datetime.now()
        )
        self._positions[symbol] = new_position

        if persist and self.position_repo:
            self.position_repo.save(new_position)

        return realized_pnl

    def get_all_positions(self) -> Dict[str, Position]:
        """Get all current positions. Compatibility method for TradingRunner."""
        return self._positions.copy()
